package com.codebreeze.algorithms;

import com.codebreeze.algorithms.Math2.Exponent;

import java.util.*;

import static com.codebreeze.algorithms.Math2.divisorsOf;
import static com.codebreeze.algorithms.Math2.findPerfectPower;
import static java.util.Arrays.asList;
import static java.util.Collections.singleton;

/*
Distinct powers
Problem 29
Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

2^2=4, 2^3=8, 2^4=16, 2^5=32
3^2=9, 3^3=27, 3^4=81, 3^5=243
4^2=16, 4^3=64, 4^4=256, 4^5=1024
5^2=25, 5^3=125, 5^4=625, 5^5=3125
If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
 */
public class DistinctPowers
{

    public static long calculateBrute(final long min, final long max)
    {
        final Map<Long, List<List<Long>>> results = new HashMap<>();
        final Set<List<Long>> pairs = new HashSet<>();
        for(long i = min; i <= max; i++)
        {
            for(long j = min; j <= max; j++)
            {
                final long result = Power.apply(i, j);
                if(results.keySet().contains(result))
                {
                    results.get(result).add(asList(i, j));
                }
                else
                {
                    final List<List<Long>> values = new ArrayList<>(2);
                    pairs.add(asList(i, j));
                    values.add(asList(i, j));
                    results.put(result, values);
                }
            }
        }
        results.entrySet()
               .stream()
               .filter( entry -> entry.getValue().size() > 1)
               .forEach(System.out::println);
        return results.size();
    }

    /*
    what we are trying to do here is to simplify every number to its base a^b, by finding out if a is perfect power,
    then finding the smallest base and updating the power accordingly, this way we can identify duplicates. For example:
    9^2 = (3^2)^2 = 3 ^ 4
    8^2 = (2^3)^2 = 2 ^ 6
    4^3 = (2^2)^3 = 2 ^ 6
    you can see that the last two are duplicates, while we did not know that earlier!
     */
    public static long calculateStoreReduced(final long min, final long max)
    {
        final Map<Long, Set<Long>> values = new HashMap<>();
        for(long i = min; i <= max; i++)
        {
            final Exponent perfectPower = findPerfectPower(i);
            if (perfectPower == null) // non perfect powers add unique combinations, so just add them
            {
                for (long j = min; j <= max; j++)
                {
                    if(values.get(i) == null)
                    {
                        values.put(i, new HashSet<>(singleton(j)));
                    }
                    else
                    {
                        values.get(i).add(j);
                    }
                }
            }
            else
            {
                for (long j = min; j <= max; j++)
                {
                    if(values.get(perfectPower.base) == null)
                    {
                        values.put(perfectPower.base, new HashSet<>(singleton(j * perfectPower.power)));
                    }
                    else
                    {
                        values.get(perfectPower.base).add(j * perfectPower.power);
                    }
                }
            }
        }
        return values.values() // sets of distinct powers associated with each basic base
                     .stream()
                     .mapToInt(Set::size) //count those distinct powers
                     .sum(); // sum those counts
    }

    public static long calculateCounting(final long min, final long max)
    {
        long count = (max - min + 1) * (max - min + 1);
        long repeats = 0;
        for(long i = min; i <= max; i++)
        {
            final Exponent perfectPower = findPerfectPower(i);
            if (perfectPower == null) // non perfect powers add unique combinations, so just add them
            {
                //nothing to do, cz non perfect power cannot generate duplicates.
            }
            else
            {
                for(long j = min; j < max; j++)
                {
                    final long reducedCandidateB = perfectPower.power * j;
                    if(reducedCandidateB <= max)
                    {
                        //this is the simple case of: a^b = c^d^e = c^(d*e), where d * e < max
                        //this is always a repeat with c^ whatever.
                        repeats++;
                    }
                    else
                    {
                        //we want to find if this perfect power number i^j can be decomposed to another perfect power before it, focus on before it, i.e. a < current a
                        //if yes, then it is a repeat of that number. For example:
                        //when min,max = 2,8   then 4^6 and 8^4 are equivalent, but neither are a repeat of 2^12, because 12 is greater than the max 8
                        //so when we hit 4^6, it is decomposed into 2^2^6 = 2^12. Now, can we decompose it to a^b such that a < 4, i.e. current a,
                        //and with both b < max and > min? the answer is no (i tried and failed). so 4^6 is NOT a repeat.
                        //however, once we hit 8^4 = 2^3^4 = 2^12, we ask the same question, can we find 8^4 = a^b, such that a < 8 and > min,
                        // and b < max and b > min? the answer is yes. With 2^12, we can find divisors of 12 = 2, 3, 4, 6, 12, then try each as follows:
                        // b = 12/12 = 1 => fails cz b is less than minimum
                        // b = 12/6  = 2 => fails cz 6 is greater than 3 (the current decomposed power), which means it is not before it
                        // b = 12/4 = 3  => fails cz 4 is greater than 3 (the current decomposed power), which means it is not before it
                        // b = 12/3 = 4  => fails cz 3 is equal to 3 (the power we decomposed the current a, which is 8, to)
                        // b = 12/2 = 6  => succeeds cz 2 is less than 3 (so the base is another base before the current bas), AND 6, which is b, is > min and < max.
                        // This indicates 8^4 is a repeat
                        // so, let's implement that
                        final Set<Long> candidateBDivisors = divisorsOf(reducedCandidateB, false, false);
                        final boolean isRepeatOfSomethingNonBasicBefore = candidateBDivisors
                                .stream()
                                .filter(divisor -> divisor < perfectPower.power)
                                .anyMatch(divisor -> {
                                    final long newB = reducedCandidateB / divisor;
                                    return newB >= min && newB <= max;
                                });
                        if(isRepeatOfSomethingNonBasicBefore)
                        {
                            repeats++;
                        }
                    }
                }
            }
        }
        return count - repeats;
    }

    private static <T> List<T> diff(final List<T> superset, final List<T> subset)
    {
        final List<T> result = new LinkedList<>(superset);
        for(final T item : subset)
        {
            result.remove(item);
        }
        return result;
    }
}
